JavaScript Higher Order Functions :-

A higher-order function is a function that does one of the following:

Takes another function as an argument.
Returns another function as its result.
Higher-order functions help make your code more reusable and modular by allowing you to work with functions like any other value.

function fun() {
    console.log("Hello, World!");
}
function fun2(action) {
    action();
}

fun2(fun);

output:-
Hello, World

@@ Popular Higher Order Functions in JavaScript
1. map
The map function is used to transform an array by applying a callback function to each element. 
It returns a new array.
const n = [1, 2, 3, 4, 5];
const square = n.map((num) => num * num);
console.log(square);

output:- 1,4,9,16,25

2. filter
The filter function is used to create a new array containing elements that satisfy a given condition.
const n = [1, 2, 3, 4, 5];
const even = n.filter((num) => num % 2 === 0);
console.log(even);

output:-
2,4

3. reduce
The reduce function accumulates array elements into a single value based on a callback function.
const n = [1, 2, 3, 4, 5];
const sum = n.reduce((acc, curr) => acc + curr, 0);
console.log(sum);

output: 15

@@ Advanced Techniques with Higher Order Functions
1. Function Composition
Function composition is the process of combining multiple functions to create a new function. The composed function applies multiple operations in sequence.
function add(x) {
    return x + 2;
}
function mul(x) {
    return x * 3;
}

function compose(f, g) {
    return function(x) {
        return f(g(x));
  };
}
var res = compose(add, mul)(4);
console.log(res);

output:-
10

2. Currying
Currying transforms a function that takes multiple arguments into a series of functions that each take one argument. This allows partial application of the function.
function mul(x) {
    return function(y) {
        return x * y;
  };
}
var mulFn = mul(2);
console.log(mulFn(5));

output:-
10

3. Memoization
Memoization is a technique where function results are cached so that repeated calls with the same arguments return faster. This is particularly useful for expensive function calls
function memoize(func) {
    var cache = {};
    return function (arg) {
        if (cache[arg]) {
            return cache[arg];
        } else {
            var res = func(arg);
            cache[arg] = res;
            return res;
        }
    };
}
function slow(num) {
    console.log("Computing...");
    return num * 2;
}

var fast = memoize(slow);
console.log(fast(5)); // Computing... 10
console.log(fast(5)); // 10 (cached)

output:-
Computing...
10
10
